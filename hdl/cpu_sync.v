//
// Copyright (c) 2015 University of Cambridge
// Copyright (c) 2015 Noa Zilberman
// All rights reserved.
//
//
//  File:
//        cpu_sync.v
//
//  Module:
//        cpu_sync
//
//  Author:
//        Noa Zilberman
//
//  Description:
//        This file is automatically generated with the registers towards the CPU/Software
//        and is responsible for clocks synchronization
//
// This software was developed by the University of Cambridge Computer Laboratory \n\
// under EPSRC INTERNET Project EP/H040536/1, National Science Foundation under Grant No. CNS-0855268,\n\
// and Defense Advanced Research Projects Agency (DARPA) and Air Force Research Laboratory (AFRL),\n\ 
// under contract FA8750-11-C-0249.
//
// @NETFPGA_LICENSE_HEADER_START@
//
// Licensed to NetFPGA Open Systems C.I.C. (NetFPGA) under one or more contributor
// license agreements.  See the NOTICE file distributed with this work for
// additional information regarding copyright ownership.  NetFPGA licenses this
// file to you under the NetFPGA Hardware-Software License, Version 1.0 (the
// "License"); you may not use this file except in compliance with the
// License.  You may obtain a copy of the License at:
//
//   http://www.<future link here>
//
// Unless required by applicable law or agreed to in writing, Work distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations under the License.
//
// @NETFPGA_LICENSE_HEADER_END@
//


`include "arbiter_cpu_regs_defines.v"

module cpu_sync 
#(
    parameter C_S_AXI_DATA_WIDTH    = 32,          
    parameter C_S_AXI_ADDR_WIDTH    = 32         
  )
(
    //ip clock domain
    input       clk,
    input       resetn,

    output [C_S_AXI_ADDR_WIDTH-1 : 0]               ip_awaddr,
    output [C_S_AXI_ADDR_WIDTH-1 : 0]               ip_araddr,
    output [C_S_AXI_DATA_WIDTH-1 : 0]               bus2ip_data_ip,
    input   [C_S_AXI_DATA_WIDTH-1 : 0]              ip2bus_data_ip,

    // axi clock domain
    input       AXI_ACLK,
    input       Bus2IP_Resetn,
    
    input   [C_S_AXI_ADDR_WIDTH-1 : 0]              axi_awaddr,
    input   [C_S_AXI_ADDR_WIDTH-1 : 0]              axi_araddr,
    input   [C_S_AXI_DATA_WIDTH-1 : 0]              bus2ip_data,
    input   [C_S_AXI_DATA_WIDTH/8 -1 : 0]           axi_wstrb,
    output reg [C_S_AXI_DATA_WIDTH-1 : 0]           ip2bus_data

);


  //Wires and signals

    wire [C_S_AXI_DATA_WIDTH-1 : 0]           sync_IP2Bus_Data;

    wire                                      bus2ip_fifo_empty;
    wire                                      bus2ip_fifo_almost_full;
    wire                                      ip2bus_fifo_empty;
    wire                                      ip2bus_fifo_almost_full;

    wire ack_event;
    reg ack_event_d;
    reg ack_event_d2;

     wire read_en_bus2ip;
     wire read_en_ip2bus;
     //wire bus2ip_sync_valid;

  //logic

  //Sync from AXI to module's freq
	small_async_fifo
   	#(
        .DSIZE (C_S_AXI_ADDR_WIDTH*2+C_S_AXI_DATA_WIDTH),
        .ASIZE (4),
        .ALMOST_FULL_SIZE (14),
        .ALMOST_EMPTY_SIZE (2)
	) bus2ip_async_fifo
        (
         .wdata({axi_awaddr, axi_arraddr, bus2ip_data}), /*Bus2IP_BE*/
         .winc(~bus2ip_fifo_almost_full),
         .wclk(AXI_ACLK),
         
         .rdata({ip_awaddr, ip_araddr, bus2ip_data_ip}), /*Bus2IP_BE_sync*/
         .rinc(read_en_bus2ip),
         .rclk(clk),

         .rempty(bus2ip_fifo_empty),
         .r_almost_empty(),
         .wfull(),
         .w_almost_full(bus2ip_fifo_almost_full),
         .rrst_n(resetn),
         .wrst_n(Bus2IP_Resetn)
         );

      assign read_en_bus2ip = ~bus2ip_fifo_empty;
      assign bus2ip_sync_valid = read_en_bus2ip ? 1'b1  : 1'b0;
  //Sync from module's freq to AXI

      wire ip2bus_fifo_wen;
      assign ip2bus_fifo_wen = ~resetn | ip2bus_fifo_almost_full ? 1'b0: 1'b1;

	small_async_fifo
   	#(
   	  .DSIZE (C_S_AXI_DATA_WIDTH),
          .ASIZE (4),
          .ALMOST_FULL_SIZE (14),
          .ALMOST_EMPTY_SIZE (2)
	) ip2bus_async_fifo 
	   (
        .wdata(ip2bus_data_ip),
        .winc (ip2bus_fifo_wen),
        .wclk(clk),

        .rdata(sync_IP2Bus_Data),
        .rinc(read_en_ip2bus),
        .rclk(AXI_ACLK),

        .rempty(ip2bus_fifo_empty),
        .r_almost_empty(),
        .wfull(),
        .w_almost_full(ip2bus_fifo_almost_full),
        .rrst_n(Bus2IP_Resetn),
        .wrst_n(resetn)
	   );

    assign read_en_ip2bus = ~ip2bus_fifo_empty;

//    assign ack_event = read_en_ip2bus & (sync_IP2Bus_RdAck | sync_IP2Bus_WrAck | sync_IP2Bus_Error);
    
    always @ (posedge AXI_CLK) begin
        ip2bus_data     <= #1 sync_IP2Bus_Data;
    end


//  always @(posedge Bus2IP_Clk) begin
//    ack_event_d  <= #1 ack_event;
//    ack_event_d2 <= #1 ack_event_d;
//    if (ack_event & ~(ack_event_d | ack_event_d2))
//        begin
//          IP2Bus_Data        <= #1 sync_IP2Bus_Data;
//          IP2Bus_RdAck       <= #1 read_en_ip2bus & sync_IP2Bus_RdAck;
//          IP2Bus_WrAck       <= #1 read_en_ip2bus & sync_IP2Bus_WrAck;
//          IP2Bus_Error       <= #1 read_en_ip2bus & sync_IP2Bus_Error;
//        end
//    else
//	begin
//	  IP2Bus_Data        <= #1 IP2Bus_Data;
//          IP2Bus_RdAck       <= #1 1'b0;
//          IP2Bus_WrAck       <= #1 1'b0;
//          IP2Bus_Error       <= #1 1'b0;
//	end
// end

    
 endmodule 

